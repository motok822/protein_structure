# Rustによるタンパク質の３次元構造決定
## 実行方法
cargo.tomlに依存ライブラリが記載されているので、cargo updateをまずはお願いします <br>
今回はplottersを使った簡単なビジュアライザーを書いたのですが、探索の速度という観点においてはビジュアライザーの処理が増えることによって速度が落ちてしまいます。そのため、ビジュアライザを使用するかどうかや描画する頻度をコマンドラインから設定することができます
- 通常モードの実行 <br>
` cargo run`
- ビジュアライザモード <br>
` cargo run -- --vis --step 10` <br>
このようにして実行することによってカレントディレクトリにanimated.gifというgifファイルが生成されます。これは実行中から観察することができ、どのように探索が進んでいるのかをオンタイムで調べることができます。なお、ビジュアライザーモードを使わなかった場合でも最終結果だけはanimated.gifという形式で出力するようになっているので、速度を求めている場合はそのようにしてください。<br>
また、ビジュアライザではHが赤、Pが青となるように表示されています

また、現在の実装ではタンパク質の例として[この論文](https://bmcbioinformatics.biomedcentral.com/counter/pdf/10.1186/1471-2105-6-30.pdf)に記載されている21個とテスト用の1つのタンパク質をPROTEIN_DATAという配列で持っています。この中から任意のタンパク質と2Dまたは3Dを選択することによって、所望の結果を得ることができます。
`cargo run -- --dim 2 --id 10`とすると2次元で10番目のタンパク質を折りたたんでくれます。<br>
## 使用したアルゴリズム
今回のタンパク質の構造決定をビームサーチを用いて解きました。今回は二次元と三次元のどちらの場合にも対応できるような設計となっています。ビーム幅は200をデフォルト設定としています。探索方法や評価関数について詳しく述べたいと思います。
#### 評価関数
評価関数は(H-H間の結合の個数) - (タンパク質全体のアミノ酸分子の最大距離)/ 3.0<br>
という関数を用いています。最大距離の項はなるべくアミノ酸が密集していた方がスコアが高くなるため入れたこうになります。
#### 探索方法
探索は二つの関数one_stepとlocal_one_stepによって行われています。それぞれについて解説します。
- one_step関数 <br>
まず[この論文](https://bmcbioinformatics.biomedcentral.com/counter/pdf/10.1186/1471-2105-6-30.pdf)に記載されているように、タンパク質の結合の方向を二次元の場合であれば[S, R, L]の3つ、三次元の場合であれば[S, R, L, U, D]の５つ存在しています。アミノ酸の全ての結合の箇所を前から順に見ていき、前述の全ての方向に進んだ場合の評価関数の値を調べてその中から良いものを200個取ってくるものになっています。ただし、愚直に上から200個取ってくると同じような方向のものばかりが選ばれてしまうため、以下のように正規分布的にスコアの良いものが選ばれるようなアルゴリズムを書いています(xが上から何番目に良い回答かを表しています)
```rust
let exp = (-8.0 * (x * x) as f32
    / ((self.beam_width * self.beam_width) as f32))
    .exp();
let mut rng = rand::thread_rng();
let prob = rng.gen_range(0.0..1.0) as f32;
if prob < exp {
    x += 1;
    new_nodes.push(node.clone());
}
```
- local_one_step関数<br>
上のようなone_step関数だけで解を探索しても最適解までは遠い値になってしまいました。その原因はアミノ酸の結合の角度を一箇所変えてしまうと、その結合より後ろのアミノ酸の位置が大きく変わってしまうため、局所的な探索ができていないということです。そのためlocal_one_step関数ではone_step関数の出力結果からより良い解を局所的に探してくれる関数です。どのように実装されているかというとアミノ酸の結合の中から5の長さの連続する部分を持っていきます。そして、0番目のアミノ酸の位置と5番目のアミノ酸の位置を変更せずに間のアミノ酸の位置を変えていき良かったものを200個取ってくるというものです。<br>
このように実装することによって間の5つのアミノ酸の位置しか変わらないためone_step関数では果たせなかった局所的な解の探索をすることができています。<br>
この関数がこの探索のボトルネックになっている部分で、間の5つのアミノ酸の位置のうち実現可能なもののみを全探索しており、だいぶ計算量を削減しているがかなり時間を食っています。

これらの二つのアルゴリズムをもとにして探索を行っていますが、one_step関数とlocal_one_step関数の実行が終わるたびに現在のベストスコアを表示してくれるため、どれくらい探索が進んでいるのかを観察することができるようになっています。
#### 結果
- 2D <br>
二次元でビームサーチを回したところ（通常モード）、最適解の95%程度の値を取ることができています。実行時間は11番などのアミノ酸の個数が100となっている大きな場合で10分程度になります。今回のビームサーチでは同じビームサーチを異なる初期解から4回試して、最も良かったものを選択しているため、この回数を減らせば実行時間は1/4になります。実行していただければわかると思いますが、1回のみの実行でも大抵95%程度の値になっていることが確認できると思います。
- 3D <br>
三次元の場合は難しく最適解の70%程度の値に落ち着いてしまっています。
#### 改善点
2Dでの結果はだいぶ良かったものの3Dへと拡張すると精度が落ちてしまった。これからこのモデルの精度を上げてくための方法として考えられるものを述べようと思う。
- 初期解の設定
現在ビームサーチを行う際の初期解の設定は単純にランダムに結合の向きを決めていき、同じ座標上にアミノ酸をはいつするようなことにならなければそれを採用するというとても単純なものになっています。なので初期解をより工夫したものにすることで精度が向上する可能性があります
- 探索方法
ビームサーチによる探索では終盤の方ではビーム幅の中に解の候補たちが同じような値になってしまっており、解の多様性が失われている傾向が見て取れます。なので、乱数の要素を強めることや、異なる親から派生してきた解を採用するなどの重み付けをつけると解の多様性が上がるかもしれません。[Qiitaの記事](https://qiita.com/rhoo/items/f2be256cde5ad2e62dde)で言及されていましたが、実装するまでは至りませんでした。
 
 #### 最後に
 今回はビームサーチを用いましたが、これ以外に通常の焼きなまし法及びacoも実装しました。acoは実装が間違えているのか全く探索が進んでいませんでしたが、焼きなまし法に関しては探索は進んでいたものの、ビームサーチの方が良いと判断したため、ビームサーチとしました。ビームサーチは割と直感的にかけてとてもやりやすいなと感じました。rustもあまり書いたことのない言語だったので難しかったですが、速度が早かったので気に入りました。